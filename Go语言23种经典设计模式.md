# Go语言23种经典设计模式教程

以下教程按设计模式类别组织，每种模式包含**定义**、**适用场景**、**优缺点**和**代码示例**四个部分。代码示例使用Go语言，并带有详细中文注释。

## 一、创建型模式

### 1. 单例模式（Singleton）
#### 定义  
单例模式是一种**创建型设计模式**，用于确保一个类只有一个实例，并提供一个全局访问点 ([Singleton](https://refactoring.guru/design-patterns/singleton#:~:text=Singleton%20is%20a%20creational%20design,global%20access%20point%20to%20this%C2%A0instance)) ([Singleton pattern - Wikipedia](https://en.wikipedia.org/wiki/Singleton_pattern#:~:text=In%20object,coordinate%20actions%20across%20a%20system))。即无论何处需要该类实例，都返回同一个对象，而不是每次创建新实例。

#### 适用场景  
当系统中**需要唯一实例**来协调全局行为时使用单例模式 ([Singleton](https://refactoring.guru/design-patterns/singleton#:~:text=1,a%20database%20or%20a%20file)) ([Singleton pattern - Wikipedia](https://en.wikipedia.org/wiki/Singleton_pattern#:~:text=In%20object,coordinate%20actions%20across%20a%20system))。例如：  
- 配置管理：整个应用只需一个全局配置对象。  
- 日志系统：使用一个全局日志器实例。  
- 数据库连接池或访问对象：控制对共享资源（数据库、文件）的访问 ([Singleton](https://refactoring.guru/design-patterns/singleton#:~:text=1,a%20database%20or%20a%20file))。  

这些场景下，单例提供全局访问点并可延迟初始化（lazy initialization） ([Singleton pattern - Wikipedia](https://en.wikipedia.org/wiki/Singleton_pattern#:~:text=Singletons%20are%20often%20preferred%20to,3))。

#### 优缺点  
- 优点：避免频繁创建对象，节省资源；提供全局访问点；可延迟初始化，避免初始化时机不明 ([Singleton pattern - Wikipedia](https://en.wikipedia.org/wiki/Singleton_pattern#:~:text=Singletons%20are%20often%20preferred%20to,3))。  
- 缺点：单例常被视为**反模式**，因为它引入全局状态，增加代码耦合度，破坏模块化，给单元测试带来困难 ([Singleton in Go / Design Patterns](https://refactoring.guru/design-patterns/singleton/go/example#example-0#:~:text=Singleton%20is%20a%20creational%20design,it%20for%20any%20other%20code)) ([Singleton pattern - Wikipedia](https://en.wikipedia.org/wiki/Singleton_pattern#:~:text=Some%20consider%20the%20singleton%20to,10))。也可能违反单一职责原则，且在并发下需额外处理线程安全（如使用`sync.Once`）。

#### 代码示例  
下面示例通过`sync.Once`实现线程安全的单例配置对象`Config`。多次调用`GetConfig()`总是返回同一实例，并且只会加载一次配置。

```go
package main

import (
    "fmt"
    "sync"
)

// Config 表示应用配置的结构体
// 在程序生命周期内只会有一个实例（单例）
type Config struct {
    settings map[string]string // 存储配置项的map
}

var (
    once           sync.Once
    configInstance *Config
)

// loadConfig 从配置源（例如文件、环境变量等）加载配置信息
func loadConfig() *Config {
    fmt.Println("加载配置文件...")
    settings := map[string]string{
        "appName": "MyApp",
        "version": "1.0.0",
    }
    return &Config{settings: settings}
}

// GetConfig 返回全局唯一的 Config 实例
func GetConfig() *Config {
    // 只执行一次加载配置操作
    once.Do(func() {
        configInstance = loadConfig()
    })
    return configInstance
}

func main() {
    // 模拟并发环境下的多次调用
    var wg sync.WaitGroup
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            cfg := GetConfig()
            fmt.Printf("协程 %d, 配置实例地址: %p, 设置: %v\n", id, cfg, cfg.settings)
        }(i)
    }
    wg.Wait()
}
```

### 2. 抽象工厂模式（Abstract Factory）
#### 定义  
抽象工厂模式是一种**创建型模式**，提供一个接口来创建一系列相关或依赖对象族，而无需指定它们的具体类 ([Abstract Factory](https://refactoring.guru/design-patterns/abstract-factory#:~:text=Abstract%20Factory%20is%20a%20creational,objects%20without%20specifying%20their%20concrete%C2%A0classes)) ([Understanding Design Patterns: Abstract Factory - DEV Community](https://dev.to/carlillo/understanding-design-patterns-abstract-factory-23e7#:~:text=,Oriented%20Software))。也就是说，通过同一个工厂接口，可以创建同一“产品族”中的不同具体产品。

#### 适用场景  
当系统有多个产品系列（产品族），并且希望在不指定具体类的情况下创建产品时使用抽象工厂。例如 ([Abstract Factory](https://refactoring.guru/design-patterns/abstract-factory#:~:text=Abstract%20Factory%20is%20a%20creational,objects%20without%20specifying%20their%20concrete%C2%A0classes))：  
- GUI库：需要在不同操作系统或主题风格下创建一套相关的控件（如Windows和Mac的按钮、复选框）。  
- 家具工厂：现代风格和维多利亚风格的椅子、沙发等产品族，使用抽象工厂分别创建对应风格的家具 ([Abstract Factory](https://refactoring.guru/design-patterns/abstract-factory#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,consists%20of%20classes%20that%20represent))。  
- 车系制造：汽车的不同级别（豪华/经济）和类型（轿车/SUV）等。

#### 优缺点  
- 优点：**隔离具体类**，使客户端与具体产品解耦；确保同一工厂创建的产品之间兼容；遵守开闭原则，引入新的产品族无需修改客户端代码 ([Understanding Design Patterns: Abstract Factory - DEV Community](https://dev.to/carlillo/understanding-design-patterns-abstract-factory-23e7#:~:text=,same%20factory%20class%20is%20guaranteed))。  
- 缺点：系统增加了新的抽象层和很多新的类；每增加一个产品（例如新类型的椅子或沙发）都需要修改所有具体工厂，增加复杂度 ([Understanding Design Patterns: Abstract Factory - DEV Community](https://dev.to/carlillo/understanding-design-patterns-abstract-factory-23e7#:~:text=However%2C%20the%20main%20drawback%20of,gaining%20abstraction%20in%20the%20code))。

#### 代码示例  
下面示例通过抽象工厂创建现代风格（`ModernFurnitureFactory`）和维多利亚风格（`VictorianFurnitureFactory`）的椅子和沙发，实现产品族的创建 ([Abstract Factory](https://refactoring.guru/design-patterns/abstract-factory#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,consists%20of%20classes%20that%20represent))。

```go
package main

import "fmt"

// ------------------------ 抽象产品 ------------------------
// 椅子的接口
type Chair interface {
	Sit() string
}

// 沙发的接口
type Sofa interface {
	LieOn() string
}

// ------------------------ 具体产品 ------------------------
// 现代风格的椅子
type ModernChair struct{}

func (c *ModernChair) Sit() string {
	return "坐在现代风格椅子上"
}

// 维多利亚风格的椅子
type VictorianChair struct{}

func (c *VictorianChair) Sit() string {
	return "坐在维多利亚风格椅子上"
}

// 现代风格的沙发
type ModernSofa struct{}

func (s *ModernSofa) LieOn() string {
	return "躺在现代风格沙发上"
}

// 维多利亚风格的沙发
type VictorianSofa struct{}

func (s *VictorianSofa) LieOn() string {
	return "躺在维多利亚风格沙发上"
}

// ------------------------ 抽象工厂 ------------------------
// 家具工厂接口，定义创建椅子和沙发的方法
type FurnitureFactory interface {
	CreateChair() Chair
	CreateSofa() Sofa
}

// ------------------------ 具体工厂 ------------------------
// 现代家具工厂
type ModernFurnitureFactory struct{}

func (f *ModernFurnitureFactory) CreateChair() Chair {
	return &ModernChair{}
}

func (f *ModernFurnitureFactory) CreateSofa() Sofa {
	return &ModernSofa{}
}

// 维多利亚家具工厂
type VictorianFurnitureFactory struct{}

func (f *VictorianFurnitureFactory) CreateChair() Chair {
	return &VictorianChair{}
}

func (f *VictorianFurnitureFactory) CreateSofa() Sofa {
	return &VictorianSofa{}
}

// ------------------------ 客户端代码 ------------------------
func main() {
	var factory FurnitureFactory

	// 创建现代风格家具
	factory = &ModernFurnitureFactory{}
	chair1 := factory.CreateChair()
	sofa1 := factory.CreateSofa()
	fmt.Println(chair1.Sit())
	fmt.Println(sofa1.LieOn())

	// 创建维多利亚风格家具
	factory = &VictorianFurnitureFactory{}
	chair2 := factory.CreateChair()
	sofa2 := factory.CreateSofa()
	fmt.Println(chair2.Sit())
	fmt.Println(sofa2.LieOn())
}
```

### 3. 建造者模式（Builder）
#### 定义  
建造者模式是一种**创建型模式**，让你能够逐步构建复杂对象。不同于其他创建型模式，建造者模式将对象的构造过程与表示分离，使同样的构造过程可以创建不同表示 ([Builder](https://refactoring.guru/design-patterns/builder#:~:text=Builder%20is%20a%20creational%20design,object%20using%20the%20same%20construction%C2%A0code)) ([Builder](https://refactoring.guru/design-patterns/builder#:~:text=The%20Builder%20pattern%20lets%20you,the%20product%20while%20it%E2%80%99s%20being%C2%A0built))。

#### 适用场景  
当一个对象有很多可选参数或子部件，构造过程复杂时，可使用建造者模式 ([Builder](https://refactoring.guru/design-patterns/builder#:~:text=Imagine%20a%20complex%20object%20that,all%20over%20the%20client%20code)) ([Builder](https://refactoring.guru/design-patterns/builder#:~:text=The%20Builder%20pattern%20lets%20you,the%20product%20while%20it%E2%80%99s%20being%C2%A0built))。例如：  
- 配置复杂的对象（如图形界面窗口需要多个组件）。  
- 构建包含多个部分的“套餐”或“菜单”，如快餐套餐包含汉堡、饮料、薯条等。  

#### 优缺点  
- 优点：**将构建逻辑与表示解耦**，相同的构造步骤可创建不同类型的产品；便于分步构造复杂对象；符合单一职责原则，每个具体建造器只负责一个产品的构建 ([Builder Design Pattern Explained Easily - DEV Community](https://dev.to/techishdeep/builder-design-pattern-explained-easily-57g9#:~:text=As%20the%20construction%20process%20is,required%20to%20build%20the%20product))。  
- 缺点：每个产品需要对应一个具体建造器，类较多；产品的创建过程相对繁琐，增加了代码量 ([Builder Design Pattern Explained Easily - DEV Community](https://dev.to/techishdeep/builder-design-pattern-explained-easily-57g9#:~:text=There%20is%20a%20close%20coupling,the%20pattern%20a%20little%20difficult))。

#### 代码示例  
下面示例使用建造者模式创建素食套餐和非素食套餐，每个套餐由汉堡和饮料组成 ([Builder](https://refactoring.guru/design-patterns/builder#:~:text=The%20Builder%20pattern%20lets%20you,the%20product%20while%20it%E2%80%99s%20being%C2%A0built)) ([Builder Design Pattern Explained Easily - DEV Community](https://dev.to/techishdeep/builder-design-pattern-explained-easily-57g9#:~:text=As%20the%20construction%20process%20is,required%20to%20build%20the%20product))。`MealBuilder`按需构造不同套餐。

```go
package main

import "fmt"

// Item 接口表示套餐中的物品
type Item interface {
	Name() string   // 名称
	Price() float64 // 价格
	Packing() string // 打包方式
}

// VegBurger 是素食汉堡
type VegBurger struct{}

func (v *VegBurger) Name() string    { return "素食汉堡" }
func (v *VegBurger) Price() float64  { return 25.0 }
func (v *VegBurger) Packing() string { return "Wrapper" }

// ChickenBurger 是鸡肉汉堡
type ChickenBurger struct{}

func (c *ChickenBurger) Name() string    { return "鸡肉汉堡" }
func (c *ChickenBurger) Price() float64  { return 35.0 }
func (c *ChickenBurger) Packing() string { return "Wrapper" }

// Coke 是可乐饮料
type Coke struct{}

func (c *Coke) Name() string    { return "可乐" }
func (c *Coke) Price() float64  { return 12.0 }
func (c *Coke) Packing() string { return "Bottle" }

// Pepsi 是百事可乐
type Pepsi struct{}

func (p *Pepsi) Name() string    { return "百事可乐" }
func (p *Pepsi) Price() float64  { return 15.0 }
func (p *Pepsi) Packing() string { return "Bottle" }

// Meal 表示一个套餐，由多个物品组成
type Meal struct {
	items []Item
}

func (m *Meal) AddItem(item Item) {
	m.items = append(m.items, item)
}
func (m *Meal) GetCost() float64 {
	var cost float64
	for _, item := range m.items {
		cost += item.Price()
	}
	return cost
}
func (m *Meal) ShowItems() {
	for _, item := range m.items {
		fmt.Printf("Item: %s, Packing: %s, Price: %.2f\n",
			item.Name(), item.Packing(), item.Price())
	}
}

// MealBuilder 是构建者，用于按需创建不同的套餐
type MealBuilder struct{}

func (mb *MealBuilder) PrepareVegMeal() *Meal {
	meal := &Meal{}
	meal.AddItem(&VegBurger{})
	meal.AddItem(&Coke{})
	return meal
}

func (mb *MealBuilder) PrepareNonVegMeal() *Meal {
	meal := &Meal{}
	meal.AddItem(&ChickenBurger{})
	meal.AddItem(&Pepsi{})
	return meal
}

func main() {
	builder := &MealBuilder{}

	// 创建素食套餐
	vegMeal := builder.PrepareVegMeal()
	fmt.Println("素食套餐包含:")
	vegMeal.ShowItems()
	fmt.Printf("总价: %.2f\n\n", vegMeal.GetCost())

	// 创建非素食套餐
	nonVegMeal := builder.PrepareNonVegMeal()
	fmt.Println("非素食套餐包含:")
	nonVegMeal.ShowItems()
	fmt.Printf("总价: %.2f\n", nonVegMeal.GetCost())
}
```

### 4. 工厂方法模式（Factory Method）
#### 定义  
工厂方法模式是一种**创建型模式**，它定义了在父类中创建对象的接口，但让子类决定要实例化的类。工厂方法使得一个类的实例化推迟到其子类 ([Factory Method](https://refactoring.guru/design-patterns/factory-method#:~:text=Factory%20Method%20is%20a%20creational,of%20objects%20that%20will%20be%C2%A0created)) ([Factory Method](https://refactoring.guru/design-patterns/factory-method#:~:text=The%20Factory%20Method%20pattern%20suggests,often%20referred%20to%20as%20products))。

#### 适用场景  
当需要在不修改客户端代码的情况下，灵活地引入新产品类型时使用工厂方法 ([Factory Method](https://refactoring.guru/design-patterns/factory-method#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,class)) ([Factory Method](https://refactoring.guru/design-patterns/factory-method#:~:text=There%E2%80%99s%20a%20slight%20limitation%20though%3A,type%20declared%20as%20this%20interface))。例如：  
- 物流管理：根据不同运输方式（卡车、船只）创建`Transport`对象 ([Factory Method](https://refactoring.guru/design-patterns/factory-method#:~:text=All%20products%20must%20follow%20the,same%C2%A0interface))。  
- 图形界面：根据不同操作系统创建对应的按钮、窗口。  
- 日志系统：根据配置创建不同类型的日志记录器。

#### 优缺点  
- 优点：封装对象创建逻辑，客户端只依赖接口，不直接使用`new`；符合开闭原则，增加新产品类时只需增加相应工厂子类；客户端与具体产品解耦 ([Factory Method](https://refactoring.guru/design-patterns/factory-method#:~:text=Subclasses%20can%20alter%20the%20class,being%20returned%20by%20the%20factory%C2%A0method))。  
- 缺点：每个产品类型都需要对应一个具体工厂类，增加类数量；对于简单场景有些冗余。

#### 代码示例  
下面示例通过工厂方法让不同子类决定创建`Transport`产品。`RoadLogistics`工厂创建卡车，`SeaLogistics`工厂创建船只 ([Factory Method](https://refactoring.guru/design-patterns/factory-method#:~:text=All%20products%20must%20follow%20the,same%C2%A0interface)) ([Factory Method](https://refactoring.guru/design-patterns/factory-method#:~:text=There%E2%80%99s%20a%20slight%20limitation%20though%3A,type%20declared%20as%20this%20interface))。

```go
package main

import "fmt"

// Transport 是产品接口，所有具体运输工具都实现这个接口
type Transport interface {
	Deliver() string
}

// Truck 是具体产品，代表卡车
type Truck struct{}

func (t *Truck) Deliver() string {
	return "使用卡车陆路运输"
}

// Ship 是具体产品，代表船
type Ship struct{}

func (s *Ship) Deliver() string {
	return "使用船舶海路运输"
}

// Logistics 是工厂接口，定义了工厂方法 CreateTransport
type Logistics interface {
	CreateTransport() Transport
}

// RoadLogistics 是具体工厂，用于创建卡车运输
type RoadLogistics struct{}

func (r *RoadLogistics) CreateTransport() Transport {
	return &Truck{}
}

// SeaLogistics 是具体工厂，用于创建船舶运输
type SeaLogistics struct{}

func (s *SeaLogistics) CreateTransport() Transport {
	return &Ship{}
}

func main() {
	var logistics Logistics
	// 假设根据需求选择不同的工厂
	needSea := true
	if needSea {
		logistics = &SeaLogistics{}
	} else {
		logistics = &RoadLogistics{}
	}

	transport := logistics.CreateTransport()
	fmt.Println(transport.Deliver())
}
```

### 5. 原型模式（Prototype）
#### 定义  
原型模式是一种**创建型模式**，通过复制已有对象来创建新对象，而无需依赖它们的具体类 ([Prototype](https://refactoring.guru/design-patterns/prototype#:~:text=Prototype%20is%20a%20creational%20design,your%20code%20dependent%20on%20their%C2%A0classes))。即提供一种机制，将一个对象作为原型，对其进行复制以产生新对象。

#### 适用场景  
当一个类实例的初始化成本较高，或需要大量相似对象时，可以使用原型模式。尤其是对象状态多且变化少时，复制原型比重新构造更高效 ([Prototype](https://refactoring.guru/design-patterns/prototype#:~:text=An%20object%20that%20supports%20cloning,as%20an%20alternative%20to%20subclassing))。例如：游戏中的粒子、角色模板、文档编辑器中的撤销功能（按状态复制）等。

#### 优缺点  
- 优点：可以**快速创建对象**，避免重新进行复杂初始化；在运行时动态配置对象；允许对象自己决定如何复制（拷贝字段） ([Prototype](https://refactoring.guru/design-patterns/prototype#:~:text=The%20Prototype%20pattern%20delegates%20the,method))。  
- 缺点：需要为每个对象实现复制（深拷贝）接口，特别是对象包含复杂引用时需小心深拷贝；增加额外的克隆机制代码。

#### 代码示例  
下面示例演示游戏中角色对象的克隆（原型）。通过`Clone()`方法深拷贝角色的属性（包括切片和映射），创建独立的副本。

```go
package main

import "fmt"

// Character 表示游戏角色
type Character struct {
	Name       string
	Level      int
	Equipment  []string
	Attributes map[string]int
}

// Clone 实现 Character 的克隆（深拷贝）
func (c *Character) Clone() *Character {
	// 深拷贝切片
	cloneEquipment := make([]string, len(c.Equipment))
	copy(cloneEquipment, c.Equipment)
	// 深拷贝映射
	cloneAttributes := make(map[string]int)
	for k, v := range c.Attributes {
		cloneAttributes[k] = v
	}
	return &Character{
		Name:       c.Name,
		Level:      c.Level,
		Equipment:  cloneEquipment,
		Attributes: cloneAttributes,
	}
}

func main() {
	// 创建一个基本角色原型
	prototype := &Character{
		Name:       "勇士",
		Level:      1,
		Equipment:  []string{"剑", "盾牌"},
		Attributes: map[string]int{"力量": 10, "敏捷": 8},
	}

	// 克隆原型创建新角色
	char1 := prototype.Clone()
	char1.Name = "勇士副本1"
	char1.Attributes["力量"] = 12 // 修改克隆角色的属性

	char2 := prototype.Clone()
	char2.Name = "勇士副本2"
	char2.Equipment = append(char2.Equipment, "铠甲") // 修改克隆角色的装备

	fmt.Println("原型角色:", prototype.Name, prototype.Level, prototype.Equipment, prototype.Attributes)
	fmt.Println("克隆角色1:", char1.Name, char1.Level, char1.Equipment, char1.Attributes)
	fmt.Println("克隆角色2:", char2.Name, char2.Level, char2.Equipment, char2.Attributes)
}
```

## 二、结构型模式

### 6. 适配器模式（Adapter）
#### 定义  
适配器模式是一种**结构型模式**，允许将两个接口不兼容的对象协同工作 ([Adapter](https://refactoring.guru/design-patterns/adapter#:~:text=Adapter%20is%20a%20structural%20design,objects%20with%20incompatible%20interfaces%20to%C2%A0collaborate))。适配器将一个对象的接口转换成客户希望的另一个接口，从而可以在不修改现有代码的情况下，将原本不兼容的类结合起来使用。

#### 适用场景  
当需要**集成不兼容的接口**时使用适配器模式 ([Adapter](https://refactoring.guru/design-patterns/adapter#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,and%20diagrams%20for%20the%20user)) ([Adapter](https://refactoring.guru/design-patterns/adapter#:~:text=You%20can%20create%20an%20adapter,another%20object%20can%20understand%20it))。例如：  
- 文件格式转换：如示例中股票数据从XML转为JSON格式， ([Adapter](https://refactoring.guru/design-patterns/adapter#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,and%20diagrams%20for%20the%20user))。  
- 系统迁移或升级：现有系统使用旧接口，新系统接口不同，通过适配器进行兼容。  
- 对接第三方库：无法修改第三方代码时，通过适配器将其接口转换为本地使用的接口。

#### 优缺点  
- 优点：能够复用现有类，不修改其源代码；通过适配器封装复杂的转换逻辑，使客户端只与适配后的接口交互；提高了代码复用性和灵活性 ([Adapter](https://refactoring.guru/design-patterns/adapter#:~:text=You%20can%20create%20an%20adapter,another%20object%20can%20understand%20it))。  
- 缺点：增加了额外的类和代码，增大系统复杂度；可能影响性能（额外一层转换），并且过度使用可能掩盖设计问题。

#### 代码示例  
下面示例使用适配器模式将XML格式的数据转换为JSON格式。`XMLDataSource`提供XML数据，`Adapter`将其转换并传递给只支持JSON格式的分析系统 ([Adapter](https://refactoring.guru/design-patterns/adapter#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,and%20diagrams%20for%20the%20user)) ([Adapter](https://refactoring.guru/design-patterns/adapter#:~:text=You%20can%20create%20an%20adapter,another%20object%20can%20understand%20it))。

```go
package main

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
)

// AnalyticsSystem 接口表示第三方分析系统，接收 JSON 数据
type AnalyticsSystem interface {
	Analyze(data string)
}

// ConcreteAnalytics 是第三方系统，真正使用 JSON 数据
type ConcreteAnalytics struct{}

func (a *ConcreteAnalytics) Analyze(data string) {
	fmt.Println("分析系统收到JSON数据:", data)
}

// StockDataXML 表示原始股票数据格式（XML）
type StockDataXML struct {
	Symbol string `xml:"symbol"`
	Price  int    `xml:"price"`
}

// XMLDataSource 是现有系统提供的数据源，只能提供 XML 格式
type XMLDataSource struct{}

func (ds *XMLDataSource) GetStockData() string {
	// 返回模拟的 XML 数据
	return `<stock><symbol>GOOG</symbol><price>2735</price></stock>`
}

// Adapter 将 XML 转换为 JSON，并调用分析系统
type Adapter struct {
	xmlSource *XMLDataSource
	analytics AnalyticsSystem
}

func (a *Adapter) AnalyzeXMLData() {
	// 从 XML 数据源获取数据
	xmlStr := a.xmlSource.GetStockData()
	// 将 XML 转换为结构体
	var data StockDataXML
	if err := xml.Unmarshal([]byte(xmlStr), &data); err != nil {
		fmt.Println("XML解析错误:", err)
		return
	}
	// 将结构体转为 JSON
	jsonBytes, _ := json.Marshal(data)
	// 调用第三方分析系统
	a.analytics.Analyze(string(jsonBytes))
}

func main() {
	xmlSource := &XMLDataSource{}
	analytics := &ConcreteAnalytics{}

	// 使用适配器使得 XML 数据与期望的 JSON 接口兼容
	adapter := &Adapter{xmlSource: xmlSource, analytics: analytics}
	adapter.AnalyzeXMLData()
}
```

### 7. 桥接模式（Bridge）
#### 定义  
桥接模式是一种**结构型模式**，它将一个类的抽象部分与实现部分分离，使它们可以独立变化 ([Bridge](https://refactoring.guru/design-patterns/bridge#:~:text=Bridge%20is%20a%20structural%20design,be%20developed%20independently%20of%20each%C2%A0other)) ([Bridge](https://refactoring.guru/design-patterns/bridge#:~:text=This%20problem%20occurs%20because%20we%E2%80%99re,common%20issue%20with%20class%20inheritance))。即通过组合（而非继承）方式，使抽象层和实现层各自独立扩展。

#### 适用场景  
当一个类的维度变化（比如形状/大小与颜色/材质等）呈**乘法组合**时，应避免类层次不断膨胀，此时使用桥接模式 ([Bridge](https://refactoring.guru/design-patterns/bridge#:~:text=Say%20you%20have%20a%20geometric,RedSquare)) ([Bridge](https://refactoring.guru/design-patterns/bridge#:~:text=This%20problem%20occurs%20because%20we%E2%80%99re,common%20issue%20with%20class%20inheritance))。例如：  
- 图形系统：形状（圆形、方形）和颜色（红色、蓝色）可以独立变化 ([Bridge](https://refactoring.guru/design-patterns/bridge#:~:text=Say%20you%20have%20a%20geometric,RedSquare)) ([Bridge](https://refactoring.guru/design-patterns/bridge#:~:text=Following%20this%20approach%2C%20we%20can,shape%20hierarchy%2C%20and%20vice%20versa))。  
- 设备控制：不同型号与不同品牌的控制器组合。  
- 数据输出：不同格式的文档与不同操作系统的打印实现。

#### 优缺点  
- 优点：抽象和实现**分离独立扩展**；在两者之间提供了桥接结构，避免类爆炸；遵守开闭原则，增加新抽象或实现层类时不影响另一侧 ([Bridge](https://refactoring.guru/design-patterns/bridge#:~:text=The%20Bridge%20pattern%20attempts%20to,and%20behaviors%20within%20one%20class))。  
- 缺点：增加了复杂性，需要额外的桥接类和接口；初学者可能不易理解。

#### 代码示例  
下面示例使用桥接模式，将颜色（`Color`）和形状（`Shape`）解耦。通过将具体颜色注入具体形状，实现同一形状可以使用不同颜色绘制 ([Bridge](https://refactoring.guru/design-patterns/bridge#:~:text=The%20Bridge%20pattern%20attempts%20to,and%20behaviors%20within%20one%20class)) ([Bridge](https://refactoring.guru/design-patterns/bridge#:~:text=Following%20this%20approach%2C%20we%20can,shape%20hierarchy%2C%20and%20vice%20versa))。

```go
package main

import "fmt"

// Color 接口表示颜色实现层
type Color interface {
	Fill() string
}

// Red 和 Blue 是具体的颜色实现
type Red struct{}
func (r *Red) Fill() string {
	return "红色"
}

type Blue struct{}
func (b *Blue) Fill() string {
	return "蓝色"
}

// Shape 接口表示抽象部分
type Shape interface {
	Draw()
}

// Circle 具体形状，持有颜色引用
type Circle struct {
	color Color
}

func (c *Circle) Draw() {
	fmt.Println("绘制圆形，颜色:", c.color.Fill())
}

// Square 具体形状，持有颜色引用
type Square struct {
	color Color
}

func (s *Square) Draw() {
	fmt.Println("绘制正方形，颜色:", s.color.Fill())
}

func main() {
	// 创建不同颜色的实现
	red := &Red{}
	blue := &Blue{}

	// 使用桥接，将颜色与形状组合
	circle := &Circle{color: red}
	square := &Square{color: blue}

	circle.Draw()
	square.Draw()

	// 可以在运行时改变形状的颜色
	circle.color = blue
	fmt.Println("改变后的颜色：")
	circle.Draw()
}
```

### 8. 组合模式（Composite）
#### 定义  
组合模式是一种**结构型模式**，允许将对象组合成树形结构，然后像对待单个对象一样对待组合结构中的对象 ([Composite](https://refactoring.guru/design-patterns/composite#:~:text=Composite%20is%20a%20structural%20design,as%20if%20they%20were%20individual%C2%A0objects))。通过统一接口，客户可以一致地访问叶节点和组合节点。

#### 适用场景  
当你的模型可以表示为树形结构时使用组合模式 ([Composite](https://refactoring.guru/design-patterns/composite#:~:text=Using%20the%20Composite%20pattern%20makes,be%20represented%20as%20a%20tree))。例如：  
- 目录结构：文件和文件夹可以递归组合成目录树。  
- 图形界面：容器组件（窗体、面板）包含其他组件或控件。  
- 订单系统：订单项可以是单一商品或装箱的商品（箱子里还有其他商品） ([Composite](https://refactoring.guru/design-patterns/composite#:~:text=Using%20the%20Composite%20pattern%20makes,be%20represented%20as%20a%20tree))。

#### 优缺点  
- 优点：使客户端对**单个对象和组合对象**的处理一致化；简化客户端代码，无需区分叶节点或组合节点；易于构建复杂树形结构 ([Composite](https://refactoring.guru/design-patterns/composite#:~:text=The%20Composite%20pattern%20suggests%20that,for%20calculating%20the%20total%20price)) ([Composite](https://refactoring.guru/design-patterns/composite#:~:text=The%20Composite%20pattern%20lets%20you,all%20components%20of%20an%20object%C2%A0tree))。  
- 缺点：可能会导致设计中出现许多小类；在安全模式下，客户必须注意区分叶节点和复合节点，否则可能误用某些方法。

#### 代码示例  
下面示例将产品和箱子组合成订单结构。`Product`表示叶子节点，`Box`表示组合节点。`Box`可以包含多个`Item`（`Product`或子`Box`），并递归计算总价 ([Composite](https://refactoring.guru/design-patterns/composite#:~:text=The%20Composite%20pattern%20suggests%20that,for%20calculating%20the%20total%20price)) ([Composite](https://refactoring.guru/design-patterns/composite#:~:text=The%20Composite%20pattern%20lets%20you,all%20components%20of%20an%20object%C2%A0tree))。

```go
package main

import "fmt"

// Item 接口，表示产品或箱子
type Item interface {
	Price() float64
}

// Product 是叶子节点，表示单个产品
type Product struct {
	name  string
	price float64
}

func (p *Product) Price() float64 {
	return p.price
}

// Box 是组合节点，可以包含多个 Item（产品或子箱子）
type Box struct {
	items []Item
}

func (b *Box) Add(item Item) {
	b.items = append(b.items, item)
}
func (b *Box) Price() float64 {
	total := 0.0
	for _, item := range b.items {
		total += item.Price()
	}
	// 假设增加包装成本
	total += 2.0
	return total
}

func main() {
	// 创建产品
	p1 := &Product{name: "产品A", price: 10.0}
	p2 := &Product{name: "产品B", price: 20.0}
	p3 := &Product{name: "产品C", price: 15.0}

	// 创建一个装有p1和p2的大箱子
	bigBox := &Box{}
	bigBox.Add(p1)
	bigBox.Add(p2)

	// 创建一个装有p3的小箱子
	smallBox := &Box{}
	smallBox.Add(p3)

	// 将小箱子也放入大箱子
	bigBox.Add(smallBox)

	fmt.Printf("订单总价: %.2f\n", bigBox.Price())
}
```

### 9. 装饰模式（Decorator）
#### 定义  
装饰器模式是一种**结构型模式**，允许动态地向对象添加额外职责。装饰器将原始对象放在特殊包装对象中，通过组合的方式来扩展功能 ([Decorator](https://refactoring.guru/design-patterns/decorator#:~:text=Decorator%20is%20a%20structural%20design,wrapper%20objects%20that%20contain%20the%C2%A0behaviors))。

#### 适用场景  
当需要在运行时为对象添加功能，且不希望使用子类进行静态继承时使用装饰器模式 ([Decorator](https://refactoring.guru/design-patterns/decorator#:~:text=But%20then%20someone%20reasonably%20asked,%E2%80%9D))。例如：  
- 动态扩展对象行为：在不修改原有类的前提下，给对象添加新的功能（如日志、加密、缓存等）。  
- 界面UI：给窗口或控件动态添加滚动条、边框等装饰。  
- 输入输出：Java中的`BufferedInputStream`即包装一个`InputStream`以增加缓冲功能。

#### 优缺点  
- 优点：比继承更灵活，允许在运行时动态叠加功能；遵守开放-封闭原则，可对不同组合进行扩展；多种装饰器可任意组合。  
- 缺点：会产生很多细小的装饰类，增加系统复杂度；层层包装使调试和理解变得更困难；如果使用不当，可能替代了更简单的设计。

#### 代码示例  
下面示例为饮料添加调料。基本饮料（`Espresso`、`HouseBlend`）实现`Beverage`接口，装饰器（`Milk`、`Mocha`）通过嵌入（composition）方式包装饮料实例，实现动态添加功能 ([Decorator](https://refactoring.guru/design-patterns/decorator#:~:text=Decorator%20is%20a%20structural%20design,wrapper%20objects%20that%20contain%20the%C2%A0behaviors)) ([Decorator](https://refactoring.guru/design-patterns/decorator#:~:text=But%20then%20someone%20reasonably%20asked,%E2%80%9D))。

```go
package main

import "fmt"

// Beverage 接口表示饮料
type Beverage interface {
	Description() string
	Cost() float64
}

// Espresso 是具体的饮料
type Espresso struct{}

func (e *Espresso) Description() string {
	return "意大利浓咖啡"
}
func (e *Espresso) Cost() float64 {
	return 30.0
}

// HouseBlend 是具体的饮料
type HouseBlend struct{}

func (h *HouseBlend) Description() string {
	return "混合咖啡"
}
func (h *HouseBlend) Cost() float64 {
	return 20.0
}

// Decorator 抽象装饰器，嵌入 Beverage
type Decorator struct {
	beverage Beverage
}

func (d *Decorator) Description() string {
	return d.beverage.Description()
}
func (d *Decorator) Cost() float64 {
	return d.beverage.Cost()
}

// Milk 是具体装饰器，为饮料添加牛奶
type Milk struct {
	Decorator
}

func (m *Milk) Description() string {
	return m.beverage.Description() + ", 加牛奶"
}
func (m *Milk) Cost() float64 {
	return m.beverage.Cost() + 5.0
}

// Mocha 是具体装饰器，为饮料添加摩卡
type Mocha struct {
	Decorator
}

func (m *Mocha) Description() string {
	return m.beverage.Description() + ", 加摩卡"
}
func (m *Mocha) Cost() float64 {
	return m.beverage.Cost() + 7.0
}

func main() {
	var beverage Beverage = &Espresso{}
	fmt.Printf("%s: %.2f元\n", beverage.Description(), beverage.Cost())

	// 给浓咖啡添加牛奶装饰
	beverage = &Milk{Decorator{beverage}}
	fmt.Printf("%s: %.2f元\n", beverage.Description(), beverage.Cost())

	// 再给加了牛奶的咖啡添加摩卡装饰
	beverage = &Mocha{Decorator{beverage}}
	fmt.Printf("%s: %.2f元\n", beverage.Description(), beverage.Cost())
}
```

### 10. 外观模式（Facade）
#### 定义  
外观模式是一种**结构型模式**，为复杂子系统提供一个**简化接口** ([Facade](https://refactoring.guru/design-patterns/facade#:~:text=Facade%20is%20a%20structural%20design,any%20other%20complex%20set%20of%C2%A0classes))。外观对象负责与子系统的各个类协作，客户端通过外观接口访问子系统的功能，从而减少客户端与子系统的耦合 ([Facade](https://refactoring.guru/design-patterns/facade#:~:text=A%20facade%20is%20a%20class,that%20clients%20really%20care%20about))。

#### 适用场景  
当需要简化与复杂子系统的交互时使用外观模式 ([Facade](https://refactoring.guru/design-patterns/facade#:~:text=Imagine%20that%20you%20must%20make,correct%20order%2C%20and%20so%20on)) ([Facade](https://refactoring.guru/design-patterns/facade#:~:text=For%20instance%2C%20an%20app%20that,you%E2%80%99ll%20have%20your%20first%20facade))。例如：  
- 封装多个子系统：在图形界面或应用程序中，为文件操作、网络通信等子系统提供统一易用的接口。  
- 第三方库封装：应用仅需要库的一部分功能时，可通过外观隐藏不必要的细节。 ([Facade](https://refactoring.guru/design-patterns/facade#:~:text=For%20instance%2C%20an%20app%20that,you%E2%80%99ll%20have%20your%20first%20facade))。  

#### 优缺点  
- 优点：简化客户端调用；降低与子系统之间的耦合度；在高层模块和低层子系统之间提供一个统一接口 ([Facade](https://refactoring.guru/design-patterns/facade#:~:text=A%20facade%20is%20a%20class,that%20clients%20really%20care%20about)) ([Facade](https://refactoring.guru/design-patterns/facade#:~:text=1,operate%20all%20the%20moving%20parts))。  
- 缺点：外观模式可能不适用于所有场景，过度抽象可能隐藏子系统的完整功能；增加外观类也会增加一个抽象层，但通常这是可接受的权衡。

#### 代码示例  
下面示例定义一个视频发布系统的外观。子系统包括认证、编码和上传等步骤，`VideoFacade`类提供了一个简化的`Publish`方法，使客户端无需直接操作各个子系统 ([Facade](https://refactoring.guru/design-patterns/facade#:~:text=A%20facade%20is%20a%20class,that%20clients%20really%20care%20about)) ([Facade](https://refactoring.guru/design-patterns/facade#:~:text=For%20instance%2C%20an%20app%20that,you%E2%80%99ll%20have%20your%20first%20facade))。

```go
package main

import "fmt"

// Authenticator 认证子系统
type Authenticator struct{}

func (a *Authenticator) Authenticate(user, pass string) bool {
	// 模拟认证过程
	fmt.Println("验证用户身份")
	return (user == "admin" && pass == "123456")
}

// VideoEncoder 视频编码子系统
type VideoEncoder struct{}

func (e *VideoEncoder) Encode(videoFile string) string {
	// 模拟编码过程
	fmt.Println("对视频进行编码:", videoFile)
	return "encoded-" + videoFile
}

// CDNUploader 内容分发网络上传子系统
type CDNUploader struct{}

func (c *CDNUploader) Upload(encodedVideo string) {
	// 模拟上传过程
	fmt.Println("上传视频到CDN:", encodedVideo)
}

// VideoFacade 为外部提供简化接口
type VideoFacade struct {
	auth     *Authenticator
	encoder  *VideoEncoder
	uploader *CDNUploader
}

func NewVideoFacade() *VideoFacade {
	return &VideoFacade{
		auth:     &Authenticator{},
		encoder:  &VideoEncoder{},
		uploader: &CDNUploader{},
	}
}

// Publish 将整个视频上传过程封装在一个方法中
func (f *VideoFacade) Publish(user, pass, videoFile string) {
	if !f.auth.Authenticate(user, pass) {
		fmt.Println("认证失败")
		return
	}
	encoded := f.encoder.Encode(videoFile)
	f.uploader.Upload(encoded)
}

func main() {
	facade := NewVideoFacade()
	// 客户端只需要调用外观的 Publish 方法
	facade.Publish("admin", "123456", "video.mp4")
}
```

### 11. 享元模式（Flyweight）
#### 定义  
享元模式是一种**结构型模式**，通过共享对象来**节省内存**。它让系统能够使用较少的对象实例，通过外部传入上下文（外在状态），将可共享的内在状态提取到共享对象中 ([Flyweight](https://refactoring.guru/design-patterns/flyweight#:~:text=Flyweight%20is%20a%20structural%20design,of%20the%20data%20in%20each%C2%A0object)) ([Flyweight](https://refactoring.guru/design-patterns/flyweight#:~:text=On%20closer%20inspection%20of%20the,the%20same%20color%20and%20sprite))。

#### 适用场景  
当程序使用大量对象，且这些对象大多可以共享某些状态时使用享元模式 ([Flyweight](https://refactoring.guru/design-patterns/flyweight#:~:text=On%20closer%20inspection%20of%20the,the%20same%20color%20and%20sprite)) ([Flyweight](https://refactoring.guru/design-patterns/flyweight#:~:text=This%20constant%20data%20of%20an,is%20called%20the%20extrinsic%20state))。典型例子：  
- 图形/游戏：大量相同类型的粒子、纹理或字符对象，共享公共属性（颜色、形状） ([Flyweight](https://refactoring.guru/design-patterns/flyweight#:~:text=On%20closer%20inspection%20of%20the,the%20same%20color%20and%20sprite))。  
- 文本编辑：字符对象共享字体、格式等，只区别外部状态（位置）。  
- 缓存池：避免重复创建相同的可共享对象。

#### 优缺点  
- 优点：大幅降低对象数量，节省系统资源；共享相同的内在状态，只有外部状态由客户端提供 ([Flyweight](https://refactoring.guru/design-patterns/flyweight#:~:text=The%20Flyweight%20pattern%20suggests%20that,of%20these%20objects%20since%20they)) ([Flyweight](https://refactoring.guru/design-patterns/flyweight#:~:text=Image%3A%20Flyweight%20pattern%20solution))。  
- 缺点：需要额外管理外部状态；实现复杂，需要分清内在状态和外在状态；对系统耦合性要求较高。

#### 代码示例  
下面示例模拟游戏中粒子的享元模式：`ParticleFlyweight`只存储类型和颜色（内在状态），多个粒子共享同一享元对象。`FlyweightFactory`确保相同类型和颜色的粒子只创建一次，从而节省内存 ([Flyweight](https://refactoring.guru/design-patterns/flyweight#:~:text=On%20closer%20inspection%20of%20the,the%20same%20color%20and%20sprite)) ([Flyweight](https://refactoring.guru/design-patterns/flyweight#:~:text=This%20constant%20data%20of%20an,is%20called%20the%20extrinsic%20state))。

```go
package main

import "fmt"

// ParticleFlyweight 表示粒子享元对象，只包含共享的内在状态
type ParticleFlyweight struct {
	Type  string // 粒子类型（例如子弹、导弹等）
	Color string // 颜色
}

// Draw 根据外部状态绘制粒子
func (p *ParticleFlyweight) Draw(x, y int) {
	fmt.Printf("绘制 %s (颜色：%s) 在位置 (%d,%d)\n", p.Type, p.Color, x, y)
}

// FlyweightFactory 管理共享的粒子享元对象
type FlyweightFactory struct {
	flyweights map[string]*ParticleFlyweight
}

func NewFlyweightFactory() *FlyweightFactory {
	return &FlyweightFactory{flyweights: make(map[string]*ParticleFlyweight)}
}

// GetFlyweight 返回指定类型和颜色的享元对象，如果不存在则创建一个
func (f *FlyweightFactory) GetFlyweight(particleType, color string) *ParticleFlyweight {
	key := particleType + ":" + color
	if fw, exists := f.flyweights[key]; exists {
		return fw
	}
	// 创建新的享元并保存
	fw := &ParticleFlyweight{Type: particleType, Color: color}
	f.flyweights[key] = fw
	return fw
}

func main() {
	factory := NewFlyweightFactory()

	// 模拟大量相同类型的粒子
	particles := []struct {
		Type  string
		Color string
		X     int
		Y     int
	}{
		{"子弹", "红色", 10, 20},
		{"子弹", "红色", 30, 40},
		{"导弹", "蓝色", 50, 60},
		{"子弹", "红色", 70, 80},
		{"导弹", "蓝色", 90, 100},
	}

	// 绘制粒子
	for _, p := range particles {
		fw := factory.GetFlyweight(p.Type, p.Color)
		fw.Draw(p.X, p.Y)
	}
}
```

### 12. 代理模式（Proxy）
#### 定义  
代理模式是一种**结构型模式**，为其他对象提供一种替身或占位符，以控制对原对象的访问。在客户端与目标对象之间引入代理对象，代理可以在请求到达真实对象之前或之后执行额外操作 ([Proxy](https://refactoring.guru/design-patterns/proxy#:~:text=Proxy%20is%20a%20structural%20design,gets%20through%20to%20the%20original%C2%A0object))。

#### 适用场景  
- **控制访问**：真实对象创建或使用成本高昂时，可使用代理延迟初始化（虚拟代理） ([Proxy](https://refactoring.guru/design-patterns/proxy#:~:text=Why%20would%20you%20want%20to,to%20time%2C%20but%20not%20always))。例如：懒加载大对象（图片、数据库连接等）。  
- **附加功能**：在调用真实对象前后执行额外操作，如权限检查、安全控制、日志记录、缓存等 ([Proxy](https://refactoring.guru/design-patterns/proxy#:~:text=The%20proxy%20disguises%20itself%20as,the%20real%20database%20object%20even%C2%A0knowing))。  
- **远程代理**：为远程对象提供本地占位，如RPC/网络代理。  

#### 优缺点  
- 优点：客户端无需知道代理和真实对象的区别，透明地增强原对象功能；符合单一职责原则，将“附加行为”放到代理类中 ([Proxy](https://refactoring.guru/design-patterns/proxy#:~:text=The%20Proxy%20pattern%20suggests%20that,all%20the%20work%20to%20it)) ([Proxy](https://refactoring.guru/design-patterns/proxy#:~:text=But%20what%E2%80%99s%20the%20benefit%3F%20If,expects%20a%20real%20service%20object))。  
- 缺点：增加系统的复杂性，引入额外的代理层；代理对象和真实对象需要实现相同接口，增加代码量；请求需经过代理，会带来一定的性能开销。

#### 代码示例  
下面示例是一个图片加载的懒加载代理：`RealImage`为真实图片，加载耗时；`ProxyImage`在第一次调用时才实例化并加载真实图片，后续调用直接使用已加载的图片，从而延迟了资源占用 ([Proxy](https://refactoring.guru/design-patterns/proxy#:~:text=Why%20would%20you%20want%20to,to%20time%2C%20but%20not%20always)) ([Proxy](https://refactoring.guru/design-patterns/proxy#:~:text=The%20Proxy%20pattern%20suggests%20that,all%20the%20work%20to%20it))。

```go
package main

import (
	"fmt"
	"time"
)

// Image 接口，声明 Display 方法
type Image interface {
	Display()
}

// RealImage 是实际的图片类，加载耗时
type RealImage struct {
	filename string
}

// NewRealImage 创建 RealImage 时模拟加载
func NewRealImage(filename string) *RealImage {
	fmt.Println("加载图片:", filename)
	time.Sleep(1 * time.Second) // 模拟加载延迟
	return &RealImage{filename: filename}
}

func (img *RealImage) Display() {
	fmt.Println("显示图片:", img.filename)
}

// ProxyImage 是 RealImage 的代理，实现懒加载
type ProxyImage struct {
	filename  string
	realImage *RealImage
}

func NewProxyImage(filename string) *ProxyImage {
	return &ProxyImage{filename: filename}
}

func (p *ProxyImage) Display() {
	// 只有第一次调用时加载真实图片
	if p.realImage == nil {
		p.realImage = NewRealImage(p.filename)
	}
	p.realImage.Display()
}

func main() {
	var img Image = NewProxyImage("test.jpg")
	// 第一次调用，真实图片被加载
	img.Display()
	// 第二次调用，不再加载，直接显示
	img.Display()
}
```

## 三、行为型模式

### 13. 责任链模式（Chain of Responsibility）
#### 定义  
责任链模式是一种**行为型模式**，它使多个处理者对象都有机会处理请求，将这些处理者连接成一条链。当请求到达时，每个处理者决定要么处理请求，要么将其传递给链上的下一个处理者 ([Chain of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility#:~:text=Chain%20of%20Responsibility%20is%20a,the%20next%20handler%20in%20the%C2%A0chain))。

#### 适用场景  
当需要让多个对象按顺序处理同一个请求，或者希望将请求在多个处理者中动态传递时使用责任链模式 ([Chain of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility#:~:text=Imagine%20that%20you%E2%80%99re%20working%20on,full%20access%20to%20all%20orders))。例如：  
- 请求验证：HTTP请求经过一系列过滤器或拦截器（身份认证、权限检查、日志等），任一处理者可以拦截请求。  
- 事件处理：GUI中控件事件由多个监听者依次处理。  
- 系统权限：登录、验证、授权等步骤依次执行 ([Chain of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility#:~:text=Imagine%20that%20you%E2%80%99re%20working%20on,full%20access%20to%20all%20orders))。

#### 优缺点  
- 优点：降低了请求的发送者和接收者之间的耦合度；可以动态地组合处理请求的对象；增强灵活性和可拓展性，每个处理者单一职责。  
- 缺点：可能不保证请求被处理；链中某个处理者决定不再传递时，请求可能终止；调试不易，因为请求经过多个对象，过程不直观。

#### 代码示例  
下面示例构造了一个由三个处理器组成的链：`AuthHandler`检查用户登录，`AdminHandler`检查管理员权限，`LoggingHandler`记录日志。请求按照顺序传递，通过责任链逐步处理 ([Chain of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility#:~:text=Imagine%20that%20you%E2%80%99re%20working%20on,full%20access%20to%20all%20orders))。

```go
package main

import "fmt"

// Request 表示请求
type Request struct {
	User     string
	LoggedIn bool
	IsAdmin  bool
}

// Handler 接口定义处理请求的方法和链接下一个处理者
type Handler interface {
	SetNext(handler Handler)
	Handle(request *Request)
}

// BaseHandler 提供默认的链接下一个处理者逻辑
type BaseHandler struct {
	next Handler
}

func (h *BaseHandler) SetNext(handler Handler) {
	h.next = handler
}

// AuthHandler 检查用户是否已登录
type AuthHandler struct {
	BaseHandler
}

func (h *AuthHandler) Handle(request *Request) {
	if !request.LoggedIn {
		fmt.Println("AuthHandler: 用户未登录，拒绝请求")
		return
	}
	fmt.Println("AuthHandler: 用户已通过身份验证")
	if h.next != nil {
		h.next.Handle(request)
	}
}

// AdminHandler 检查用户是否具有管理员权限
type AdminHandler struct {
	BaseHandler
}

func (h *AdminHandler) Handle(request *Request) {
	if request.IsAdmin {
		fmt.Println("AdminHandler: 管理员权限通过")
	} else {
		fmt.Println("AdminHandler: 普通用户，通过基本权限")
	}
	if h.next != nil {
		h.next.Handle(request)
	}
}

// LoggingHandler 记录日志
type LoggingHandler struct {
	BaseHandler
}

func (h *LoggingHandler) Handle(request *Request) {
	fmt.Println("LoggingHandler: 请求已记录（用户:", request.User, "）")
	if h.next != nil {
		h.next.Handle(request)
	}
}

func main() {
	// 创建处理器并链接顺序
	auth := &AuthHandler{}
	admin := &AdminHandler{}
	logging := &LoggingHandler{}

	auth.SetNext(admin)
	admin.SetNext(logging)

	// 登录用户请求示例
	request := &Request{User: "Alice", LoggedIn: true, IsAdmin: false}
	auth.Handle(request)

	fmt.Println()

	// 未登录用户请求示例
	request2 := &Request{User: "Bob", LoggedIn: false, IsAdmin: false}
	auth.Handle(request2)
}
```

### 14. 命令模式（Command）
#### 定义  
命令模式是一种**行为型模式**，它将请求封装为一个对象，从而使你可以将不同请求、队列化请求、记录日志或支持可撤销操作 ([Command](https://refactoring.guru/design-patterns/command#:~:text=Command%20is%20a%20behavioral%20design,request%E2%80%99s%20execution%2C%20and%20support%20undoable%C2%A0operations))。命令对象包含了执行请求所需的所有信息。

#### 适用场景  
当需要将请求以对象形式传递时使用命令模式。例如：  
- GUI按钮/菜单：将按钮事件封装为命令对象，支持撤销/重做操作。  
- 任务调度：将任务封装为命令后可放入队列延迟执行。  
- 日志记录：记录对目标对象的操作，便于恢复状态。  
- 事务处理：组合多个命令作为一个整体操作。  

#### 优缺点  
- 优点：将调用者和接收者解耦，支持请求的排队、日志记录和撤销；新增命令时无需修改现有代码，只需添加新的命令类 ([Command](https://refactoring.guru/design-patterns/command#:~:text=Command%20is%20a%20behavioral%20design,request%E2%80%99s%20execution%2C%20and%20support%20undoable%C2%A0operations))。  
- 缺点：会产生许多具体命令类，系统复杂度增加；可能增加理解难度，需要维护命令历史。

#### 代码示例  
下面示例演示一个简单的遥控器控制灯的开关。命令对象`LightOnCommand`和`LightOffCommand`封装了对`LightReceiver`的调用，`SimpleRemote`作为调用者，通过命令对象执行操作 ([Command](https://refactoring.guru/design-patterns/command#:~:text=Command%20is%20a%20behavioral%20design,request%E2%80%99s%20execution%2C%20and%20support%20undoable%C2%A0operations)) ([Command](https://refactoring.guru/design-patterns/command#:~:text=And%20here%E2%80%99s%20the%20ugliest%20part,on%20the%20keyboard))。

```go
package main

import "fmt"

// Command 接口声明执行命令的方法
type Command interface {
	Execute()
}

// LightReceiver 表示电灯的接收者
type LightReceiver struct{}

func (l *LightReceiver) TurnOn() {
	fmt.Println("灯已打开")
}

func (l *LightReceiver) TurnOff() {
	fmt.Println("灯已关闭")
}

// LightOnCommand 打开灯的命令
type LightOnCommand struct {
	light *LightReceiver
}

func (c *LightOnCommand) Execute() {
	c.light.TurnOn()
}

// LightOffCommand 关闭灯的命令
type LightOffCommand struct {
	light *LightReceiver
}

func (c *LightOffCommand) Execute() {
	c.light.TurnOff()
}

// SimpleRemote 控制器，具有按键（可绑定不同的命令）
type SimpleRemote struct {
	onCommand  Command
	offCommand Command
}

func (r *SimpleRemote) SetCommands(on, off Command) {
	r.onCommand = on
	r.offCommand = off
}

func (r *SimpleRemote) PressOn() {
	if r.onCommand != nil {
		r.onCommand.Execute()
	}
}

func (r *SimpleRemote) PressOff() {
	if r.offCommand != nil {
		r.offCommand.Execute()
	}
}

func main() {
	// 创建电灯接收者
	light := &LightReceiver{}
	// 创建对应的命令对象
	onCmd := &LightOnCommand{light: light}
	offCmd := &LightOffCommand{light: light}
	// 设置遥控器的命令
	remote := &SimpleRemote{}
	remote.SetCommands(onCmd, offCmd)

	// 按下遥控器按钮执行命令
	remote.PressOn()
	remote.PressOff()
}
```

### 15. 解释器模式（Interpreter）
#### 定义  
解释器模式是一种**行为型模式**，用于定义一种语言的文法表示，并提供一个解释器来解释语言中的句子。在需要处理特定语法的场景下，可以使用解释器模式实现自定义解析器（如简单脚本或表达式） ([Template Method](https://refactoring.guru/design-patterns/template-method#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,docs%20in%20a%20uniform%20format)) ([Visitor](https://refactoring.guru/design-patterns/visitor#:~:text=Visitor%20is%20a%20behavioral%20design,the%20objects%20on%20which%20they%C2%A0operate))（参考：**设计模式**）。

#### 适用场景  
当系统需要**解释或计算某种表达式、公式或语言**时使用解释器模式。例如：  
- 领域特定语言（DSL）：如正则表达式、数学表达式解释、配置文件解析。  
- 简单脚本：游戏或应用中内置的脚本解释引擎。  
- 语法分析：将语法树节点与解释器分离，使新增规则时能扩展解析类层次。

#### 优缺点  
- 优点：易于扩展：增加新的语法规则只需增加新的表达式类；清晰地表示文法结构。  
- 缺点：复杂的语法时会导致很多类，维护成本高；效率较低，通常只适用于简单语法的解释。

#### 代码示例  
以下为一个简单的表达式解释器示例，实现`Expression`接口，支持常量和加法运算。通过`InterpreterContext`可以解释一组表达式并计算结果（仅为示例，非完整语法解析器）。

```go
package main

import "fmt"

// Expression 接口定义解释方法
type Expression interface {
	Interpret() int
}

// NumberExpression 表示数字
type NumberExpression struct {
	Value int
}

func (n *NumberExpression) Interpret() int {
	return n.Value
}

// AddExpression 表示加法运算
type AddExpression struct {
	Left, Right Expression
}

func (a *AddExpression) Interpret() int {
	return a.Left.Interpret() + a.Right.Interpret()
}

// InterpreterContext 用于解析表达式（简化示例）
func main() {
	// 构造表达式 (5 + 10) + 20
	expr := &AddExpression{
		Left: &AddExpression{
			Left:  &NumberExpression{Value: 5},
			Right: &NumberExpression{Value: 10},
		},
		Right: &NumberExpression{Value: 20},
	}
	result := expr.Interpret()
	fmt.Printf("表达式结果: %d\n", result) // 输出 35
}
```

### 16. 迭代器模式（Iterator）
#### 定义  
迭代器模式是一种**行为型模式**，它允许顺序访问聚合对象（如集合、列表等）中的元素，而无需暴露对象的内部表示 ([Iterator](https://refactoring.guru/design-patterns/iterator#:~:text=Iterator%20is%20a%20behavioral%20design,list%2C%20stack%2C%20tree%2C%C2%A0etc))。迭代器本身维护访问当前位置的信息。

#### 适用场景  
当需要遍历不同容器对象时使用迭代器模式。例如：  
- 统一遍历不同集合（列表、树、图）中的元素，无需在客户端知道底层结构。  
- 支持多个遍历算法（前序、中序、后序、广度优先）通过不同迭代器实现。  
- 在遍历过程中可能存在多个迭代器同时操作同一个集合（它们之间相互独立） ([Iterator](https://refactoring.guru/design-patterns/iterator#:~:text=Iterators%20implement%20various%20traversal%20algorithms,same%20collection%20at%20the%20same%C2%A0time))。

#### 优缺点  
- 优点：提供统一遍历接口，屏蔽内部结构；支持多种遍历方式；多个迭代器可并行遍历同一集合 ([Iterator](https://refactoring.guru/design-patterns/iterator#:~:text=Iterators%20implement%20various%20traversal%20algorithms,same%20collection%20at%20the%20same%C2%A0time))。  
- 缺点：增加额外的迭代器类；在简单场景下使用显得冗余。

#### 代码示例  
下面示例定义了一个整数切片迭代器`IntSliceIterator`，实现`Iterator`接口，可顺序遍历切片元素 ([Iterator](https://refactoring.guru/design-patterns/iterator#:~:text=Iterator%20is%20a%20behavioral%20design,list%2C%20stack%2C%20tree%2C%C2%A0etc))。客户端使用`HasNext()`和`Next()`方法访问元素。

```go
package main

import "fmt"

// Iterator 接口提供遍历集合元素的方法
type Iterator interface {
	HasNext() bool
	Next() int
}

// IntSliceIterator 是整数切片的迭代器，实现了 Iterator 接口
type IntSliceIterator struct {
	data  []int
	index int
}

// NewIntSliceIterator 创建新的迭代器
func NewIntSliceIterator(data []int) *IntSliceIterator {
	return &IntSliceIterator{data: data, index: 0}
}

func (it *IntSliceIterator) HasNext() bool {
	return it.index < len(it.data)
}

func (it *IntSliceIterator) Next() int {
	if it.HasNext() {
		value := it.data[it.index]
		it.index++
		return value
	}
	// 无剩余元素，可返回默认值
	return 0
}

func main() {
	numbers := []int{10, 20, 30, 40, 50}
	iterator := NewIntSliceIterator(numbers)
	for iterator.HasNext() {
		value := iterator.Next()
		fmt.Println("遍历到元素:", value)
	}
}
```

### 17. 中介者模式（Mediator）
#### 定义  
中介者模式是一种**行为型模式**，用于减少多个对象之间的相互依赖。它用一个中介对象来封装对象之间的交互，使得各对象之间不再直接通信，而是通过中介者间接协作 ([Mediator](https://refactoring.guru/design-patterns/mediator#:~:text=Mediator%20is%20a%20behavioral%20design,collaborate%20only%20via%20a%20mediator%C2%A0object)) ([Mediator](https://refactoring.guru/design-patterns/mediator#:~:text=The%20Mediator%20pattern%20suggests%20that,class%20instead%20of%20being%20coupled))。

#### 适用场景  
当系统中多个对象之间的通信关系复杂时使用中介者模式 ([Mediator](https://refactoring.guru/design-patterns/mediator#:~:text=Relations%20between%20elements%20of%20the,become%20chaotic%20as%20the%20application%C2%A0evolves)) ([Mediator](https://refactoring.guru/design-patterns/mediator#:~:text=The%20Mediator%20pattern%20suggests%20that,class%20instead%20of%20being%20coupled))。例如：  
- 界面组件：表单对话框中各控件（复选框、文本框、按钮等）之间的交互，通过对话框类（中介者）协调 ([Mediator](https://refactoring.guru/design-patterns/mediator#:~:text=Relations%20between%20elements%20of%20the,become%20chaotic%20as%20the%20application%C2%A0evolves))。  
- 聊天系统：聊天室（中介者）管理用户之间的消息转发。  
- 空中交通：航管中心（中介者）协调多架飞机（同事对象）起降。

#### 优缺点  
- 优点：松散耦合：各对象只依赖中介者，而不直接联系；简化对象之间的交互逻辑，将复杂的关联集中在中介者中 ([Mediator](https://refactoring.guru/design-patterns/mediator#:~:text=The%20Mediator%20pattern%20suggests%20that,class%20instead%20of%20being%20coupled)) ([Mediator](https://refactoring.guru/design-patterns/mediator#:~:text=This%20way%2C%20the%20Mediator%20pattern,extend%20or%20reuse%20that%20class))。  
- 缺点：中介者对象可能膨胀为复杂的“上帝对象”，变得难以维护；需要额外编写中介者类和接口。

#### 代码示例  
下面示例构造了一个简单的聊天室中介者。`ChatRoom`充当中介者，管理用户列表并负责将消息广播给所有其他用户。`User`对象通过调用中介者发送和接收消息，从而避免彼此直接交互 ([Mediator](https://refactoring.guru/design-patterns/mediator#:~:text=The%20Mediator%20pattern%20suggests%20that,class%20instead%20of%20being%20coupled)) ([Mediator](https://refactoring.guru/design-patterns/mediator#:~:text=You%20can%20go%20further%20and,dialog%20that%20implements%20that%20interface))。

```go
package main

import "fmt"

// ChatMediator 中介者接口
type ChatMediator interface {
	SendMessage(msg string, sender *User)
	AddUser(user *User)
}

// ChatRoom 是具体中介者，管理用户并负责消息广播
type ChatRoom struct {
	users []*User
}

func NewChatRoom() *ChatRoom {
	return &ChatRoom{users: []*User{}}
}

func (c *ChatRoom) AddUser(user *User) {
	c.users = append(c.users, user)
}

// SendMessage 将消息广播给房间内除发送者外的所有用户
func (c *ChatRoom) SendMessage(msg string, sender *User) {
	for _, user := range c.users {
		if user != sender {
			user.Receive(msg, sender)
		}
	}
}

// User 表示聊天室用户
type User struct {
	name     string
	mediator ChatMediator
}

func NewUser(name string, mediator ChatMediator) *User {
	return &User{name: name, mediator: mediator}
}

func (u *User) Send(msg string) {
	fmt.Printf("%s 发送消息: %s\n", u.name, msg)
	u.mediator.SendMessage(msg, u)
}

func (u *User) Receive(msg string, sender *User) {
	fmt.Printf("%s 收到来自 %s 的消息: %s\n", u.name, sender.name, msg)
}

func main() {
	room := NewChatRoom()

	user1 := NewUser("Alice", room)
	user2 := NewUser("Bob", room)
	user3 := NewUser("Charlie", room)

	room.AddUser(user1)
	room.AddUser(user2)
	room.AddUser(user3)

	user1.Send("大家好！")
	user2.Send("你好，Alice！")
}
```

### 18. 备忘录模式（Memento）
#### 定义  
备忘录模式是一种**行为型模式**，允许捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象到之前的状态，而无需暴露该对象的内部细节 ([Memento](https://refactoring.guru/design-patterns/memento#:~:text=Memento%20is%20a%20behavioral%20design,revealing%20the%20details%20of%20its%C2%A0implementation))。

#### 适用场景  
当需要保存对象历史状态、支持撤销操作时使用备忘录模式 ([Memento](https://refactoring.guru/design-patterns/memento#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,format%20text%2C%20insert%20inline%20images%2C%C2%A0etc))。典型场景：  
- 文本编辑器撤销：保存每次编辑的状态快照，撤销时恢复快照 ([Memento](https://refactoring.guru/design-patterns/memento#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,format%20text%2C%20insert%20inline%20images%2C%C2%A0etc)) ([Memento](https://refactoring.guru/design-patterns/memento#:~:text=Before%20executing%20an%20operation%2C%20the,restore%20objects%20to%20their%20previous%C2%A0state))。  
- 游戏存档：保存游戏状态，以后载入恢复。  
- 配置回滚：记录配置更改前的状态，出错时恢复。

#### 优缺点  
- 优点：无需暴露对象细节即可保存和恢复状态；实现对象撤销功能。  
- 缺点：状态备份需要额外内存；如果对象状态庞大且频繁备份，会导致性能和内存开销；备忘录本身可能变得庞大。

#### 代码示例  
下面示例通过备忘录模式记录`Editor`（编辑器）的内容状态。`Memento`保存编辑器的内容字符串，`Caretaker`维护备忘录历史，实现撤销功能 ([Memento](https://refactoring.guru/design-patterns/memento#:~:text=Memento%20is%20a%20behavioral%20design,revealing%20the%20details%20of%20its%C2%A0implementation)) ([Memento](https://refactoring.guru/design-patterns/memento#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,format%20text%2C%20insert%20inline%20images%2C%C2%A0etc))。

```go
package main

import "fmt"

// Editor 表示文本编辑器，包含需要备份/恢复的内容
type Editor struct {
	content string
}

// CreateMemento 创建备忘录并保存编辑器内容
func (e *Editor) CreateMemento() *Memento {
	return &Memento{content: e.content}
}

// Restore 恢复编辑器到备忘录中的内容
func (e *Editor) Restore(m *Memento) {
	e.content = m.content
}

// Memento 备忘录类，只包含备份的内容
type Memento struct {
	content string
}

// Caretaker 管理备忘录对象的栈
type Caretaker struct {
	history []*Memento
}

func (c *Caretaker) Backup(e *Editor) {
	c.history = append(c.history, e.CreateMemento())
}

func (c *Caretaker) Undo(e *Editor) {
	if len(c.history) == 0 {
		return
	}
	// 弹出最后一个备忘录并恢复
	m := c.history[len(c.history)-1]
	c.history = c.history[:len(c.history)-1]
	e.Restore(m)
}

func main() {
	editor := &Editor{}
	caretaker := &Caretaker{}

	editor.content = "Version1"
	caretaker.Backup(editor)

	editor.content = "Version2"
	caretaker.Backup(editor)

	editor.content = "Version3"
	fmt.Println("当前内容:", editor.content)

	// 撤销到上一个版本
	caretaker.Undo(editor)
	fmt.Println("撤销后内容:", editor.content)

	// 再次撤销
	caretaker.Undo(editor)
	fmt.Println("再次撤销后内容:", editor.content)
}
```

### 19. 观察者模式（Observer）
#### 定义  
观察者模式是一种**行为型模式**，它为对象之间定义了一种一对多的发布-订阅关系，使得当一个对象状态改变时，所有依赖它的对象都会收到通知并自动更新 ([Observer](https://refactoring.guru/design-patterns/observer#:~:text=Observer%20is%20a%20behavioral%20design,happen%20to%20the%20object%20they%E2%80%99re%C2%A0observing))。

#### 适用场景  
当一个对象的状态改变需要影响其他对象，并且不知道有多少对象需要被影响时使用观察者模式 ([Observer](https://refactoring.guru/design-patterns/observer#:~:text=Observer%20is%20a%20behavioral%20design,happen%20to%20the%20object%20they%E2%80%99re%C2%A0observing)) ([Observer](https://refactoring.guru/design-patterns/observer#:~:text=The%20Observer%20pattern%20suggests%20that,removing%20them%20from%20that%20list))。例如：  
- 事件通知：GUI事件监听器（按钮点击、窗口事件等），主题对象改变时通知所有监听者。  
- 数据绑定：数据模型变化时自动更新视图。  
- 发布-订阅系统：例如商店发布新产品时通知感兴趣的客户 ([Observer](https://refactoring.guru/design-patterns/observer#:~:text=Imagine%20that%20you%20have%20two,in%20the%20store%20very%20soon))。

#### 优缺点  
- 优点：建立对象之间的松耦合关系；支持广播通信，订阅机制灵活；可动态添加或移除观察者 ([Observer](https://refactoring.guru/design-patterns/observer#:~:text=The%20Observer%20pattern%20suggests%20that,removing%20them%20from%20that%20list)) ([Observer](https://refactoring.guru/design-patterns/observer#:~:text=That%E2%80%99s%20why%20it%E2%80%99s%20crucial%20that,data%20along%20with%20the%20notification))。  
- 缺点：观察者过多时通知开销大；观察者更新顺序不确定；循环依赖或连锁更新时可能出现复杂情况。

#### 代码示例  
下面示例构造了商店和客户的发布-订阅关系：`Store`作为发布者，允许客户（`Customer`）注册。发布者调用`NotifyAll()`方法通知所有订阅者新产品到货。 ([Observer](https://refactoring.guru/design-patterns/observer#:~:text=The%20Observer%20pattern%20suggests%20that,removing%20them%20from%20that%20list))。

```go
package main

import "fmt"

// Observer 观察者接口，定义更新方法
type Observer interface {
	Update(product string)
}

// Subject 发布者接口，定义订阅、取消订阅、通知方法
type Subject interface {
	Register(observer Observer)
	Remove(observer Observer)
	NotifyAll(product string)
}

// Store 是具体的发布者
type Store struct {
	observers []Observer
}

func (s *Store) Register(observer Observer) {
	s.observers = append(s.observers, observer)
}

func (s *Store) Remove(observer Observer) {
	for i, obs := range s.observers {
		if obs == observer {
			// 从切片中移除观察者
			s.observers = append(s.observers[:i], s.observers[i+1:]...)
			return
		}
	}
}

func (s *Store) NotifyAll(product string) {
	for _, observer := range s.observers {
		observer.Update(product)
	}
}

// Customer 是具体的观察者
type Customer struct {
	name string
}

func (c *Customer) Update(product string) {
	fmt.Printf("%s 收到通知：产品 %s 已上架！\n", c.name, product)
}

func main() {
	store := &Store{}

	customer1 := &Customer{name: "Alice"}
	customer2 := &Customer{name: "Bob"}

	// 客户订阅商店通知
	store.Register(customer1)
	store.Register(customer2)

	// 商店发布新产品，通知所有订阅的客户
	store.NotifyAll("Go语言设计模式教程")
}
```

### 20. 状态模式（State）
#### 定义  
状态模式是一种**行为型模式**，允许一个对象在内部状态改变时改变其行为，使对象看起来像修改了自己的类 ([State](https://refactoring.guru/design-patterns/state#:~:text=State%20is%20a%20behavioral%20design,if%20the%20object%20changed%20its%C2%A0class)) ([State](https://refactoring.guru/design-patterns/state#:~:text=You%20can%20also%20apply%20this,bit%20differently%20in%20each%20state))。通过将不同状态封装为独立的类，避免大量条件语句。

#### 适用场景  
当一个对象的行为依赖于其状态，且状态之间切换时使用状态模式 ([State](https://refactoring.guru/design-patterns/state#:~:text=You%20can%20also%20apply%20this,bit%20differently%20in%20each%20state))。例如：  
- 文档或帖子工作流：根据对象处于草稿、审核、已发布等状态执行不同逻辑 ([State](https://refactoring.guru/design-patterns/state#:~:text=You%20can%20also%20apply%20this,bit%20differently%20in%20each%20state))。  
- 交通信号灯：红绿灯状态变化触发不同控制。  
- 网络连接：连接的不同状态（连接中、已连接、已断开）下的行为不同。

#### 优缺点  
- 优点：将与状态相关的行为局部化到各个状态类中，使得状态转换更明显；消除了状态切换的条件语句，提高可维护性 ([State](https://refactoring.guru/design-patterns/state#:~:text=The%20biggest%20weakness%20of%20a,state%20conditionals%20in%20every%20method))。  
- 缺点：需要定义多个状态类，增加类的数量；状态类之间可能产生复杂的切换逻辑。

#### 代码示例  
下面示例实现了一个`Document`文档对象，根据`isAdmin`标记和当前状态（`DraftState`、`ModerationState`、`PublishedState`）来改变发布行为 ([State](https://refactoring.guru/design-patterns/state#:~:text=You%20can%20also%20apply%20this,bit%20differently%20in%20each%20state))。调用`Publish()`方法时，行为由当前状态类决定。

```go
package main

import "fmt"

// State 接口定义文档状态下的行为
type State interface {
	Publish(doc *Document)
}

// Document 是上下文类，包含当前状态和用户角色
type Document struct {
	state   State
	isAdmin bool
}

func (d *Document) SetState(s State) {
	d.state = s
}

func (d *Document) Publish() {
	d.state.Publish(d)
}

// 草稿状态
type DraftState struct{}

func (s *DraftState) Publish(doc *Document) {
	fmt.Println("文档在草稿状态，切换到审核状态")
	doc.SetState(&ModerationState{})
}

// 审核状态
type ModerationState struct{}

func (s *ModerationState) Publish(doc *Document) {
	if doc.isAdmin {
		fmt.Println("审核完成，文档发布")
		doc.SetState(&PublishedState{})
	} else {
		fmt.Println("审核中，只有管理员才能发布")
	}
}

// 已发布状态
type PublishedState struct{}

func (s *PublishedState) Publish(doc *Document) {
	fmt.Println("文档已发布，操作无效")
}

func main() {
	doc := &Document{state: &DraftState{}, isAdmin: false}
	doc.Publish()      // 草稿 -> 审核
	doc.Publish()      // 审核状态下非管理员，不通过
	// 切换为管理员用户
	doc.isAdmin = true
	doc.Publish()      // 审核 -> 发布
	doc.Publish()      // 已发布，无法操作
}
```

### 21. 策略模式（Strategy）
#### 定义  
策略模式是一种**行为型模式**，它定义了一系列算法，将每个算法封装起来，并使它们可以互换 ([Strategy](https://refactoring.guru/design-patterns/strategy#:~:text=Strategy%20is%20a%20behavioral%20design,class%2C%20and%20make%20their%20objects%C2%A0interchangeable))。策略模式让算法可独立于使用它的客户端变化。

#### 适用场景  
当需要在运行时选择算法或行为时使用策略模式 ([Strategy](https://refactoring.guru/design-patterns/strategy#:~:text=One%20day%20you%20decided%20to,orient%20themselves%20in%20any%20city))。例如：  
- 排序算法：可根据数据不同选择快速排序或归并排序等策略。  
- 导航路线：根据交通方式切换驾车、步行、公共交通等路线算法 ([Strategy](https://refactoring.guru/design-patterns/strategy#:~:text=One%20day%20you%20decided%20to,orient%20themselves%20in%20any%20city))。  
- 支付方式：信用卡、PayPal、微信等不同支付策略。  

#### 优缺点  
- 优点：不同的策略之间可互换，使得算法可独立扩展；清晰地封装了每种行为；符合开闭原则。  
- 缺点：使用策略模式会产生很多策略类；客户端必须知道并选择使用哪种策略。

#### 代码示例  
下面示例定义了一个`Calculator`上下文，根据设置的策略执行不同运算。`ConcreteStrategyAdd`实现加法，`ConcreteStrategyMultiply`实现乘法，客户端可通过`SetStrategy`动态切换 ([Strategy](https://refactoring.guru/design-patterns/strategy#:~:text=Strategy%20is%20a%20behavioral%20design,class%2C%20and%20make%20their%20objects%C2%A0interchangeable)) ([Strategy](https://refactoring.guru/design-patterns/strategy#:~:text=One%20day%20you%20decided%20to,orient%20themselves%20in%20any%20city))。

```go
package main

import "fmt"

// Strategy 接口定义算法方法
type Strategy interface {
	Execute(a, b int) int
}

// ConcreteStrategyAdd 实现加法策略
type ConcreteStrategyAdd struct{}

func (s *ConcreteStrategyAdd) Execute(a, b int) int {
	return a + b
}

// ConcreteStrategyMultiply 实现乘法策略
type ConcreteStrategyMultiply struct{}

func (s *ConcreteStrategyMultiply) Execute(a, b int) int {
	return a * b
}

// Calculator 上下文类，持有具体策略
type Calculator struct {
	strategy Strategy
}

func (c *Calculator) SetStrategy(s Strategy) {
	c.strategy = s
}

func (c *Calculator) Calculate(a, b int) int {
	if c.strategy == nil {
		return 0
	}
	return c.strategy.Execute(a, b)
}

func main() {
	calculator := &Calculator{}

	// 使用加法策略
	calculator.SetStrategy(&ConcreteStrategyAdd{})
	result := calculator.Calculate(5, 3)
	fmt.Printf("5 + 3 = %d\n", result)

	// 使用乘法策略
	calculator.SetStrategy(&ConcreteStrategyMultiply{})
	result = calculator.Calculate(5, 3)
	fmt.Printf("5 * 3 = %d\n", result)
}
```

### 22. 模板方法模式（Template Method）
#### 定义  
模板方法模式是一种**行为型模式**，它在抽象基类中定义了一个算法的骨架，而将一些具体步骤的实现延迟到子类 ([Template Method](https://refactoring.guru/design-patterns/template-method#:~:text=Template%20Method%20is%20a%20behavioral,the%20algorithm%20without%20changing%20its%C2%A0structure))。这样，子类可以重写算法的某些步骤，而整体结构不变。

#### 适用场景  
当多种算法的流程相似，只是部分步骤不同，且希望复用公共逻辑时使用模板方法模式 ([Template Method](https://refactoring.guru/design-patterns/template-method#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,docs%20in%20a%20uniform%20format))。例如：  
- 数据处理：不同格式的数据提取流程相似，但解析步骤不同，可以在基类定义流程 ([Template Method](https://refactoring.guru/design-patterns/template-method#:~:text=Data%20mining%20classes%20contained%20a,lot%20of%20duplicate%C2%A0code))。  
- 游戏开发：游戏循环框架在基类定义，具体游戏步骤由子类实现。  
- 框架设计：允许用户通过继承修改某些步骤而不改变框架整体流程。

#### 优缺点  
- 优点：避免了多个类的重复代码，公共部分放到父类；易于维护和扩展新算法。  
- 缺点：每增加一个新子类，需要编写新的类；增加了继承体系的复杂度，子类只能通过继承方式扩展。

#### 代码示例  
下面示例展示数据处理的模板方法。`BaseProcessor`定义了统一的`ProcessData`模板，调用`ReadData`、`ParseData`、`AnalyzeData`等步骤。`CSVProcessor`和`JSONProcessor`作为子类分别实现各自的步骤 ([Template Method](https://refactoring.guru/design-patterns/template-method#:~:text=Template%20Method%20is%20a%20behavioral,the%20algorithm%20without%20changing%20its%C2%A0structure)) ([Template Method](https://refactoring.guru/design-patterns/template-method#:~:text=Imagine%20that%20you%E2%80%99re%20creating%20a,docs%20in%20a%20uniform%20format))。

```go
package main

import "fmt"

// Processor 定义各个步骤的方法
type Processor interface {
	ReadData(filename string)
	ParseData()
	AnalyzeData()
}

// BaseProcessor 是抽象基类，实现模板方法
type BaseProcessor struct{}

func (bp *BaseProcessor) ProcessData(filename string, processor Processor) {
	fmt.Println("打开文件:", filename)
	processor.ReadData(filename)
	processor.ParseData()
	processor.AnalyzeData()
	fmt.Println("关闭文件:", filename)
}

// CSVProcessor 是具体子类，实现 CSV 读取和解析
type CSVProcessor struct{}

func (p *CSVProcessor) ReadData(filename string) {
	fmt.Println("读取 CSV 文件数据")
}
func (p *CSVProcessor) ParseData() {
	fmt.Println("解析 CSV 数据")
}
func (p *CSVProcessor) AnalyzeData() {
	fmt.Println("分析 CSV 数据")
}

// JSONProcessor 是具体子类，实现 JSON 读取和解析
type JSONProcessor struct{}

func (p *JSONProcessor) ReadData(filename string) {
	fmt.Println("读取 JSON 文件数据")
}
func (p *JSONProcessor) ParseData() {
	fmt.Println("解析 JSON 数据")
}
func (p *JSONProcessor) AnalyzeData() {
	fmt.Println("分析 JSON 数据")
}

func main() {
	base := &BaseProcessor{}
	csvProcessor := &CSVProcessor{}
	jsonProcessor := &JSONProcessor{}

	// 使用CSV处理器
	fmt.Println("处理CSV文件:")
	base.ProcessData("data.csv", csvProcessor)
	fmt.Println()

	// 使用JSON处理器
	fmt.Println("处理JSON文件:")
	base.ProcessData("data.json", jsonProcessor)
}
```

### 23. 访问者模式（Visitor）
#### 定义  
访问者模式是一种**行为型模式**，它将算法与对象结构分离，使得在不改变对象结构的前提下，可以向这些对象结构添加新的操作 ([Visitor](https://refactoring.guru/design-patterns/visitor#:~:text=Visitor%20is%20a%20behavioral%20design,the%20objects%20on%20which%20they%C2%A0operate))。访问者模式中，访问者类封装了对各元素对象的操作，通过元素对象的`accept`方法实现双重分派。

#### 适用场景  
当有一个类层次结构，需要在不修改这些类的前提下，为其添加新的功能时使用访问者模式 ([Visitor](https://refactoring.guru/design-patterns/visitor#:~:text=Imagine%20that%20your%20team%20develops,specific%20node%20is%20an%20object))。例如：  
- 对象结构操作：在复杂数据结构（如语法树、图结构）中，需要进行遍历并执行某种操作（如导出、统计） ([Visitor](https://refactoring.guru/design-patterns/visitor#:~:text=Imagine%20that%20your%20team%20develops,specific%20node%20is%20an%20object))。  
- 业务逻辑：将与对象结构无关的算法提取到外部访问者。  

#### 优缺点  
- 优点：新增操作时无需修改原有类，符合开放-封闭原则；易于在多个类上实现统一操作。  
- 缺点：增加新的元素类时需要修改访问者接口，破坏封闭；访问者与元素之间耦合，复杂性增加。

#### 代码示例  
下面示例定义了动物类层次结构和访问者`SpeakVisitor`。`Animal`接口有`Accept`方法，`Lion`和`Elephant`实现该接口。访问者`SpeakVisitor`分别对不同类型动物进行操作，实现“动物叫声”功能 ([Visitor](https://refactoring.guru/design-patterns/visitor#:~:text=Visitor%20is%20a%20behavioral%20design,the%20objects%20on%20which%20they%C2%A0operate)) ([Visitor](https://refactoring.guru/design-patterns/visitor#:~:text=Imagine%20that%20your%20team%20develops,specific%20node%20is%20an%20object))。

```go
package main

import "fmt"

// Animal 接口，接受访问者
type Animal interface {
	Accept(v AnimalVisitor)
}

// AnimalVisitor 访问者接口，对不同类型的动物定义访问方法
type AnimalVisitor interface {
	VisitLion(l *Lion)
	VisitElephant(e *Elephant)
}

// Lion 是具体元素
type Lion struct {
	Name string
}

func (l *Lion) Accept(v AnimalVisitor) {
	v.VisitLion(l)
}

// Elephant 是具体元素
type Elephant struct {
	Name string
}

func (e *Elephant) Accept(v AnimalVisitor) {
	v.VisitElephant(e)
}

// SpeakVisitor 是具体访问者，实现各动物“说话”操作
type SpeakVisitor struct{}

func (v *SpeakVisitor) VisitLion(l *Lion) {
	fmt.Println("狮子说: 我是", l.Name)
}

func (v *SpeakVisitor) VisitElephant(e *Elephant) {
	fmt.Println("大象说: 我是", e.Name)
}

func main() {
	animals := []Animal{
		&Lion{Name: "辛巴"},
		&Elephant{Name: "多莉"},
	}

	visitor := &SpeakVisitor{}
	for _, animal := range animals {
		animal.Accept(visitor)
	}
}
```

以上23种设计模式的定义、场景、优缺点和代码示例涵盖了常见用法，可作为系统学习和参考。阅读时建议结合实际项目需求，选择合适的模式以提升代码的灵活性和可维护性。

**参考资料：** 设计模式定义来源于权威资料 ([Singleton](https://refactoring.guru/design-patterns/singleton#:~:text=Singleton%20is%20a%20creational%20design,global%20access%20point%20to%20this%C2%A0instance)) ([Singleton pattern - Wikipedia](https://en.wikipedia.org/wiki/Singleton_pattern#:~:text=In%20object,coordinate%20actions%20across%20a%20system))等，示例与说明参考了相关设计模式文献。各模式的实现和解释帮助读者理解其在Go语言中的应用。 ([Adapter](https://refactoring.guru/design-patterns/adapter#:~:text=Adapter%20is%20a%20structural%20design,objects%20with%20incompatible%20interfaces%20to%C2%A0collaborate)) ([Visitor](https://refactoring.guru/design-patterns/visitor#:~:text=Visitor%20is%20a%20behavioral%20design,the%20objects%20on%20which%20they%C2%A0operate))等。